# Requirements: Schedule Task Execution

## Decision Log

### スコープ: プロジェクト単位 vs グローバル
- **Discussion**: スケジュールタスクをアプリ全体で管理するか、プロジェクトごとに管理するか
- **Conclusion**: プロジェクト単位で登録
- **Rationale**: プロジェクトごとに異なるメンテナンスタスクや自動化ニーズがある。プロジェクト固有の設定ファイルで管理することで、プロジェクトの移動や共有も容易

### 実行開始の判定基準
- **Discussion**: 「前回実行からn時間経過」の基準を成功時のみとするか、開始時点とするか
- **Conclusion**: 実行開始時点を基準（成功/失敗不問）
- **Rationale**: 失敗したタスクが即座に再実行されるのを防ぐ。リトライが必要な場合は手動で即時実行を使用

### 他Agent動作中の挙動
- **Discussion**: 他のAgentが動作中の場合の挙動（待機/スキップ）
- **Conclusion**: タスク単位でユーザー設定可能
- **Rationale**: タスクの性質によって適切な挙動が異なる。重要なタスクは待機、軽微なタスクはスキップなど柔軟に対応

### 回避ルールの対象
- **Discussion**: どの操作を回避対象として指定できるか
- **Conclusion**: spec-merge, commit, bug-merge + 他のschedule-task
- **Rationale**: マージを伴う操作は競合リスクがあり危険。スケジュールタスク同士の競合も避けるべき

### データ永続化
- **Discussion**: 設定の保存場所
- **Conclusion**: プロジェクト内ファイル（`.kiro/schedule-tasks.json`）+ Electron側での同期
- **Rationale**: プロジェクト内ファイルでバージョン管理可能、Electron同期でアプリ起動時の高速読み込み

### 複数プロンプトの実行方式
- **Discussion**: 1タスクに複数プロンプトがある場合の実行方法
- **Conclusion**: 各プロンプトごとに別々のAgent起動、条件と許可フラグ次第で並列実行可能
- **Rationale**: プロンプト間の独立性を保証。失敗が他に影響しない

### worktreeの扱い
- **Discussion**: workflowモード時のworktree命名と後処理
- **Conclusion**: 自動生成 or ユーザー指定（+日時サフィックス）、命名規則は `schedule/task-name/`、システム的には放置
- **Rationale**: 複数プロンプトで別worktreeを使用するため、タスク名でグループ化。後処理はプロンプト内で制御可能

### 即時実行と回避ルール
- **Discussion**: 即時実行時に回避ルールを適用するか
- **Conclusion**: 適用しない（ただし警告ダイアログを表示して確認）
- **Rationale**: ユーザーが明示的に即時実行を選択した場合は意図があると判断。ただしリスクは警告

### スケジュール条件の組み合わせ
- **Discussion**: 1タスクに複数条件を設定できるか
- **Conclusion**: 1タスク1スケジュール（複数条件が必要なら複数タスク作成）
- **Rationale**: シンプルさを優先。複雑な条件は複数タスクで表現

## Introduction

スケジュールに基づいてClaude Codeを自動起動し、指定プロンプトを実行する機能。定期メンテナンス、自動レビュー、リマインダー的なタスクなど、プロジェクト固有の自動化を実現する。ProjectAgent欄のタイマーアイコンからアクセスし、スケジュールタスクの一覧表示・作成・編集・削除を行う。

**Remote UI対応**: 不要（Desktop専用機能）
- 理由: スケジュールタスクはMain Processでのタイマー管理とアイドル検出が必要であり、Electron環境に密結合している。Remote UIからの操作は技術的に意味がない（スケジューラはDesktopアプリが起動していないと動作しない）

## Requirements

### Requirement 1: スケジュールタスク設定UI

**Objective:** ユーザーとして、ProjectAgent欄からスケジュールタスクの管理画面にアクセスしたい。定期実行するタスクを簡単に設定・管理できるようにするため。

#### Acceptance Criteria
1. When ユーザーがProjectAgent欄のタイマーアイコンをクリックした時、システムはScheduleTaskSettingViewダイアログを表示する
2. ScheduleTaskSettingViewは以下の構成を持つ:
   - ScheduleTaskHeader: タスク追加ボタン
   - ScheduleTaskList: 登録済みタスクの一覧
   - ScheduleTaskFooter
3. ScheduleTaskListItemは以下の情報を表示する:
   - タスク名
   - スケジュール種別（固定/条件）
   - 次回実行予定
   - 最終実行開始日時
   - 有効/無効トグル（インライン配置）
   - 削除アイコン
4. When ユーザーがScheduleTaskListItemをクリックした時、システムはScheduleTaskEditPageにスライドナビゲーション（ダイアログ内Push遷移）する
5. When ユーザーが削除アイコンをクリックした時、システムは削除確認ダイアログを表示する
6. When ユーザーが有効/無効トグルを切り替えた時、システムはタスクの有効状態を即座に更新する

### Requirement 2: スケジュールタスク編集画面

**Objective:** ユーザーとして、スケジュールタスクの詳細を設定・編集したい。柔軟なスケジュール設定と実行オプションを指定できるようにするため。

#### Acceptance Criteria
1. ScheduleTaskEditPageはSpec/Bug新規作成と同様のレイアウトを持つ
2. 以下の項目を編集可能:
   - タスク名（必須）
   - スケジュール種別の選択（固定/条件）
   - スケジュール詳細設定
   - プロンプト一覧（複数登録可能）
   - 回避ルール設定
   - workflowモード設定
   - 他Agent動作中の挙動設定
3. When ユーザーがタスク追加ボタンから新規作成した時、システムは空のScheduleTaskEditPageを表示する
4. When ユーザーが保存ボタンをクリックした時、システムはバリデーションを実行し、成功すればタスクを保存してリスト画面に戻る

### Requirement 3: 固定スケジュールパターン

**Objective:** ユーザーとして、時間ベースのスケジュールを設定したい。定期的なタスク実行を自動化するため。

#### Acceptance Criteria
1. 「前回実行からn時間経過」パターン:
   - 時間は1時間単位で指定可能
   - ショートカットボタン: 「月1回（720時間）」「週1回（168時間）」
   - 実行開始時点を基準とする（成功/失敗不問）
2. 「毎週n曜日のn時」パターン:
   - 複数曜日の選択が可能（例: 月・水・金）
   - 時刻は時間単位で指定
3. If 「アイドル後に実行」オプションが有効な場合、システムは固定時刻到達後もアイドル状態になるまで実行を待機する

### Requirement 4: 条件スケジュールパターン

**Objective:** ユーザーとして、アイドル状態をトリガーとしたスケジュールを設定したい。ユーザーが作業していない時間を活用するため。

#### Acceptance Criteria
1. 「アイドルしてn分経過したら実行」パターンを設定可能
2. アイドル時間は分単位で指定可能
3. When システムがアイドル状態をn分間検出した時、システムは該当タスクをキューに追加する

### Requirement 5: プロンプト管理

**Objective:** ユーザーとして、1つのタスクに複数のプロンプトを登録したい。関連する複数の自動化処理をグループ化するため。

#### Acceptance Criteria
1. 1つのスケジュールタスクに複数のプロンプトを登録可能
2. 各プロンプトは個別に編集・削除可能
3. プロンプトの順序を変更可能
4. When スケジュールがトリガーされた時、システムは各プロンプトごとに別々のAgentを起動する
5. 条件と許可フラグ次第で複数プロンプトの並列実行が可能

### Requirement 6: 回避ルール

**Objective:** ユーザーとして、特定の操作が実行中の場合にタスク実行を制御したい。マージ競合などの問題を防ぐため。

#### Acceptance Criteria
1. タスク単位で回避対象を指定可能:
   - spec-merge
   - commit
   - bug-merge
   - 他のschedule-task
2. タスク単位で回避時の挙動を指定可能:
   - 終了を待って実行開始
   - そのタイミングはスキップ（次のスケジュールまで待つ）
3. When 回避対象が動作中にスケジュールがトリガーされた時、システムは指定された挙動に従う

### Requirement 7: 即時実行

**Objective:** ユーザーとして、登録済みのプロンプトを即座に実行したい。スケジュールを待たずにタスクを実行するため。

#### Acceptance Criteria
1. 各タスクに即時実行ボタンを配置
2. 即時実行時は回避ルールを適用しない
3. If 回避対象（spec-merge等）が動作中に即時実行した場合、システムは警告ダイアログを表示する
4. 警告ダイアログは「それでも実行」「キャンセル」の選択肢を提供する
5. When ユーザーが「それでも実行」を選択した時、システムはタスクを強制実行する

### Requirement 8: Workflowモード

**Objective:** ユーザーとして、スケジュールタスクをworktree環境で実行したい。メインブランチへの影響を隔離するため。

#### Acceptance Criteria
1. タスク単位でworkflowモードの有効/無効を切り替え可能
2. workflowモード有効時:
   - 実行時にworktreeとブランチが自動作成される
   - 命名規則: `schedule/{task-name}/{suffix}`
   - suffixは自動生成（日時）またはユーザー指定可能
   - ユーザー指定の場合も日時サフィックスが付加される（例: `hoge-task-20260125`）
3. 複数プロンプトの場合、各プロンプトは別々のworktreeで実行される
4. 実行後のworktreeはシステム的には放置（プロンプト内での制御に委ねる）

### Requirement 9: データ永続化

**Objective:** システムとして、スケジュールタスクの設定を永続化したい。アプリ再起動後も設定を維持するため。

#### Acceptance Criteria
1. スケジュールタスク設定は `.kiro/schedule-tasks.json` に保存される
2. Electron側でもローカルストレージに同期される
3. When プロジェクトが開かれた時、システムは両方のソースから設定を読み込み、整合性を確認する
4. 各タスクの最終実行開始時間を記録する

### Requirement 10: 実行制御

**Objective:** システムとして、スケジュールされたタスクを適切なタイミングで実行したい。他の作業を妨げずに自動化を実現するため。

#### Acceptance Criteria
1. キューイング条件（スケジュール条件を満たした時点）と実行条件（実際に実行開始する条件）を分離する
2. When 固定スケジュールの時刻に到達した時、システムはタスクをキューに追加する
3. When アイドル条件を満たした時、システムはタスクをキューに追加する
4. When キューにタスクがあり、実行条件（アイドル状態、回避ルールクリア等）を満たした時、システムはタスクを実行する
5. 「アイドル後に実行」オプション有効時、固定スケジュールでもアイドル状態になるまで待機する

## Out of Scope

- 実行履歴の詳細保存・閲覧（最終実行開始時間のみ記録）
- プロンプト内の変数/プレースホルダー機能
- グローバル（アプリ全体）でのスケジュールタスク管理
- 複数スケジュール条件のAND/OR組み合わせ（1タスク1スケジュール）
- worktree実行後の自動クリーンアップ
- キューイングされたタスクの可視化UI（Document Review #1で「現時点では不要」と判断）

## Open Questions

なし（すべて解決済み）

- ~~Electron側のローカルストレージとプロジェクト内ファイルの同期タイミングと競合解決の詳細~~ → **解決**: design.md DD-004で詳細設計済み
- ~~アイドル検出の既存実装（humanActivityTracker.ts）との統合方法~~ → **解決**: design.md DD-002で方針設計済み
