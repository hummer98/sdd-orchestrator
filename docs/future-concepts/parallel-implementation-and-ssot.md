# 並列実装とSSOT問題

## 概要

SDD Orchestratorにおける並列実装の課題と、仕様書のSSOT（Single Source of Truth）をどう維持するかについての検討メモ。

_作成日: 2025-01-04_

---

## 問題の発端

### 現状の課題

1. **Specドキュメントが溜まる** - 設計フェーズは完了するが、実装が追いつかない
2. **実装の1レーン制限** - 同一フォルダで複数実装を同時実行すると干渉が発生
   - 同じソースファイルへの競合
   - テスト実行時の相互干渉

### 検討した解決策

- git worktreeで並列実装
- 別フォルダにcloneして実装 → inspection → PR

### 浮上した根本的問題

> git worktreeやcloneを使う場合、**仕様書のSSOTはどこか？**

---

## AI Agent時代のチーム開発

### 従来のチーム開発の前提

- 人間の実装速度がボトルネック → 並列化でスループット向上
- 各人が異なる専門性を持つ

### AI Agentによる変化

| 要素 | 人間チーム | AI Agent (単独) |
|------|-----------|-----------------|
| 実装速度 | 人数に比例（理論上） | 十分に高速 |
| コミュニケーションコスト | 人数²に比例 | ゼロ |
| コンテキスト共有 | 会議、ドキュメント、PR説明 | 不要（単一の脳） |
| マージコンフリクト | 頻発 | 発生しない |
| 設計の一貫性 | 努力が必要 | 自然に保たれる |

### 結論

> AI Agentの実装速度が十分に高速なら、並列化のメリットはコミュニケーションコストに打ち消される

チーム開発的な並列化は、AI Agent時代には最適解ではない可能性がある。

---

## Git/PRモデルとSDDの相性問題

### Gitの前提

- コードは「変更の提案」として分岐し、レビュー後にマージ
- 複数の変更が並行して存在するのが自然
- SSOTは「mainブランチの最新コミット」
- **分散型** - 「全体像」は誰も持っていない前提

### SDDの前提

- 仕様は「承認された真実」として存在
- 仕様に基づいて実装する（仕様が先、コードが後）
- SSOTは「.kiro/specs/の内容」
- **全体像の一貫性** - プロジェクト状態が常に把握可能であるべき

### 矛盾点

```
仕様書A（承認済み）→ 実装A → PR-A（未マージ）
                         ↓
         この時点で「仕様Aに対応する実装」は
         mainに存在しない。仕様と実装が乖離。
```

### PRの存在意義への疑問

SDDでは：
- 仕様レビュー → design承認時に完了
- 実装レビュー → inspection/TDDで品質担保

**PRで何をレビューする？**

AI Agentが仕様通りに実装し、テストも通り、inspectionもパスした場合、人間が追加でレビューする意味は？

### 2つの世界観

| | Git/PRモデル | SDD純粋モデル |
|---|---|---|
| 信頼の対象 | 人間のレビュー | 仕様 + 自動検証 |
| 変更の流れ | コード → レビュー → マージ | 仕様 → 実装 → 検証 → 即反映 |
| 並列化 | ブランチで自然に対応 | 本質的に直列？ |

### 仮説

> SDDを純粋に追求すると、**PRというステップ自体が不要になる**可能性がある

```
仕様承認 → 実装 → inspection通過 → 自動でmainにコミット
```

PRは「レビュー」ではなく「儀式」として残る。

---

## SSOTの根本問題

### Gitブランチモデルの限界

SDDが求める「全体像」：
```
プロジェクト全体像
├── 仕様A（承認済み）→ 実装済み ✓
├── 仕様B（承認済み）→ 実装中...
├── 仕様C（設計中）
└── 仕様D（要件定義中）
```

Gitブランチモデルでの現実：
```
main:     仕様A実装済み
branch-B: 仕様B実装中（mainから見えない）
branch-C: 仕様C設計中（mainから見えない）
```

**mainを見ても全体像がわからない。**

### Gitの本質

Gitは「コードの履歴管理」ツールであって、「プロジェクト状態管理」ツールではない。

| SDDが必要とするもの | Gitが提供するもの |
|-----------|------------------|
| 仕様の状態管理 | コードの履歴管理 |
| 全体の進捗可視化 | ブランチごとの差分 |
| 仕様→実装の追跡 | ファイル単位の変更追跡 |

### 新たな仮説

> **SDD Orchestratorこそが「プロジェクト全体像のSSOT」であり、Gitはその下位の「コード保存」レイヤーに過ぎない**

```
SDD Orchestrator（SSOT）
├── 仕様A: status=completed, commit=abc123
├── 仕様B: status=implementing, branch=feature-B
├── 仕様C: status=designing
└── Git（ストレージ）
    ├── main
    └── feature-B
```

---

## 検討した解決案

### 案1: 仕様書を別リポジトリに分離

```
specs-repo/           ← 仕様書専用（SSOT）
├── feature-A/
├── feature-B/
└── feature-C/

code-repo/            ← 実装コード
├── src/
└── .kiro/specs/ → specs-repoへの参照
```

**問題**: 仕様と実装の紐付けが外部参照になり、複雑化

### 案2: 仕様書はDB/外部ストレージ

```
SDD Orchestrator DB（SSOT）
├── specs: { feature-A: {...}, feature-B: {...} }
└── implementations: { feature-A: { branch: "...", status: "..." } }

Git（実装のみ）
├── main
└── feature-branches
```

**問題**: Kiro互換性を失う。`.kiro/specs/`がなくなる

### 案3: 仕様書のバージョニングを分離

```
.kiro/specs/feature-A/
├── spec.json          ← バージョン情報
├── requirements.md    ← v1.0（承認済み・不変）
├── design.md          ← v1.0（承認済み・不変）
└── tasks.md           ← v1.0（承認済み・不変）

実装ブランチ:
├── spec-version: feature-A@v1.0 を参照
└── src/ を変更
```

**問題**: 仕様変更時のバージョン管理が複雑

### 案4: 発想の転換 - 仕様書は「コミットに埋め込まれる」

Gitの履歴自体がSSOT。「最新のmain」ではなく「特定のコミット時点のspec」を参照。

**問題**: 現在進行中の複数specの全体像が見えない

---

## 根本的な問題

どの案も**しっくりこない**のは：

> 「仕様書」と「コード」を同じバージョン管理モデルで扱おうとしている

からではないか。

- 仕様書は**状態遷移**（draft → approved → implemented）
- コードは**変更履歴**（差分の積み重ね）

本質的に異なるものを、Gitという単一のモデルに押し込めようとしている。

---

## 未解決の問い

1. **仕様書マスタと実装ブランチをどう統合管理するか？**
   - 明確なビジョンが見えていない

2. **SDDにおけるGitの役割とは？**
   - 「コード保存レイヤー」に格下げするのか
   - それとも仕様管理も含めた新しいモデルを構築するのか

3. **Kiro互換性を維持しながら解決可能か？**
   - `.kiro/specs/`構造を前提とした設計との両立

4. **実装の並列化は本当に必要か？**
   - AI Agentの速度で直列実行でも十分かもしれない
   - ボトルネックが「人間の承認待ち」なら、並列化より自動化が解

---

## 次のステップ候補

- [ ] 実際の運用で「直列実装」がどこまでボトルネックになるか計測
- [ ] PRを「儀式」として割り切った運用を試行
- [ ] SDD Orchestratorを「SSOT」として位置づける設計の具体化
- [ ] Gitに代わる/補完する仕様管理モデルの調査

---

_このドキュメントは検討段階のメモであり、結論には至っていない_
